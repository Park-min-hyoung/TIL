# 7월 4일

## 오늘 한일

### `코딩 테스트`

- 백준 단계별로 풀어보기 `함수`, `기본 수학`, `재귀`
- 알고리즘 기초 Part 1 문제 풀이

<br>

## 배운 것

<br>

## 어려웠던 점

<br>

## 한줄평

> _오늘도 수고했어!!! 내일부터 공부할 때 집중하면서 하자. 힘내고._

<br>

# 7월 5일

## 오늘 한일

### `코딩 테스트`

- 알고리즘 기초 Part 1 `자료구조 1`, `자료구조 1(연습)`문제 풀이
- `에디터`, `단어 뒤집기 2` 해설, `쇠막대기` 풀이

### `React 강의`

- 노마드 코더 React 강의 수강
- Prop Type 체크, create-react-app(CRA), useEffect

### `ES6 부족한 개념 보완`

- Call & Bind & Apply 함수

<br>

## 배운 것

### `Call & Bind & Apply 함수`

> call

- 함수를 호출하는 방법으로는 ()를 붙이는 것과 더불어 call 그리고 apply 하는 방법이 있습니다.

```js
var example = function (a, b, c) {
  return a + b + c;
};
example(1, 2, 3);
example.call(null, 1, 2, 3);
example.apply(null, [1, 2, 3]);
```

- call은 일반 함수 호출 시와 똑같이 인자를 넣고 apply는 배열을 인자로 넣는다

- call과 apply에 공통적으로 있는 null은 this를 대체하는 것

```js
var obj = {
  string: "zero",
  yell: function () {
    alert(this.string);
  },
};
var obj2 = {
  string: "what",
};

obj.yell(); // 'zero';
obj.yell.call(obj2); // 'what'
```

- obj.yell.call(obj2); => this가 가르키는 것을 obj에서 obj2로 수정

```js
var kim = { name: "kim", first: 10, second: 20 };
var lee = { name: "lee", first: 100, second: 200 };

function sum(num) {
  return num + this.first + this.second;
}

sum.call(kim, 500); //sum을 call하는데 this값을 kim객체로 한다!
```

- `즉 call을 써서 this를 정의해준다면 다른 객체의 파라미터나 메소드를 자기 것마냥 사용할 수 있는 겁니다`
- .call(this. 파라미터1, 파라미터2);, .apply(this, []);

> arguments 함수를 call을 이용해 배열처럼 사용

```js
function example3() {
  // arguments는 유사배열이므로 Array 메소드를 사용할 수 없다
  // console.log(arguments.join());
  console.log(Array.prototype.join.call(arguments));
}
example3(1, "string", true); // '1,string,true'
```

1. 우선은 프로토타입 메서드 Array.prototype.join()을 불러오고 그 뒤에 .call()로 join함수를 조작합니다.
2. call(arguments)로 this를 유사배열로 가리키게 합니다. 본래는 Array객체를 가리키고 있지만 바꾼 것이죠.
   그러면 Array.prototype.join()이 최종적으로 [1, 'string', true].join() 이 되게 됩니다.

> 요약

```js
const items = [1, 4];

items.join(); // "1,4"
Array.prototype.join.call(items); // "1,4"
[].join.call(items); // "1,4"
```

> apply

- apply의 목적은 `유사 배열 객체에 배열 메소드를 사용하는 경우`

```js
function convertArgsToArray() {
  console.log(arguments);

  // arguments 유사배열 겍체를 this로 사용
  // slice: 배열의 특정 부분에 대한 복사본을 생성한다.
  var arr = Array.prototype.slice.apply(arguments); // arguments.slice
  // var arr = [].slice.apply(arguments);

  console.log(arr);
  return arr;
}

console.log(convertArgsToArray(1, 2, 3)); // [1,2,3]
```

- `Array.prototype.slice() 메소드를 호출하되 this는 arguments 객체로 바인딩하라`는 의미

> bind

- bind 함수는 함수가 가리키는 this만 바꾸고 `호출하지는 않는 것`
- this를 정의하고 나서 그 함수를 복사해 새로운 함수를 만들어 return 하는 것

```js
var obj = {
  string: "zero",
  yell: function () {
    alert(this.string);
  },
};
var obj2 = {
  string: "what",
};

var yell2 = obj.yell.bind(obj2);
yell2(); // 'what'
obj.yell.bind(obj2)(); // 'what'
```

- `call이나 apply와 비슷하지만 호출은 하지 않고 함수만 반환하는 것`
- `call(this, 1, 2, 3)은 bind(this)(1, 2, 3)`과 같다.

> 정리

- call,apply,bind 이놈은 더도 말고 그냥 참조하는 함수 조작이다.
- this를 바꿔서 마치 해당 함수가 어느 객체 안에 있게 할 수 있다.
  - yell 함수는 현재 obj에 있지만 obj2에 있는 것 처럼 사용할 수 있다.

```js
var obj = { ..., yell(){} };
var obj2 = { ... };

obj.yell.call(obj2); == obj2.yell();
```

```js
var arr = [ ... ];

Array.prototype.join.call(arr) == [].join.call(arr) == arr.join();
```

- call, apply는 바로 적용하지만 bind는 적용을 안하고 반환한다.
- 단. bind()()하면 call처럼 사용 가능

```js
var arr = [1, 2, 3, 4];
var inputArgument = [1, 2, 100, 200];

[].concat.apply(arr, inputArgument); // [1, 2, 3, 4, 1, 2, 100, 200]
```

- apply는 인수를 배열로 받는 call

- [Call & Bind & Apply 함수 출처]

[call & bind & apply 함수 출처]: https://inpa.tistory.com/entry/JS-📚-Call-Bind-Apply

### `React 강의`

> Prop Type 체크

- `<script src="https://unpkg.com/prop-types@15.7.2/prop-types.js"></script>` 추가
- React에게 props들의 type을 알려줌으로써 잘못됬을 때 Error를 볼 수있도록 함
- isRequired 통해 필수적으로 전달할 props의 전달여부 check
  - 해당 props를 전달하지 않으면 Error 발생시킴
- default parameter 이용해 props에 의해 값을 전달 받지 못했을 때 사용할 수 있는 기본 값을 설정할 수 있다.

```js
function Btn({ text, fontSize = 16 }) {
  return;
}

Btn.propTypes = {
  text: PropTypes.string.isRequired,
  fontSize: PropTypes.number,
};

function App() {
  return (
    <div>
      <Btn text="Save Changes" fontSize={18} />
      <Btn text="Continue" />
    </div>
  );
}
```

> create-react-app

- 효율적으로 react 사용 가능
- 설치 및 오류 대처
  - 명령 프롬프트에 명령어 작성
  - npm uninstall -g create-react-app
  - npm add create-react-app
  - npx create-react-app my-app => 오류 없으면 이 명령어만 작성해도 정상적으로 설치

> CRA에서의 prop type 체크

- npm i prop-types

> CRA에서의 CSS 파일사용

- 원하는이름.module.css로 파일명 설정
- react에서 css 파일을 import할 때 파일을 js의 객체로 받아온다.
- 특정 태그에 css를 적용하기 위해 특정 태그의 class명을 외우지 않아도 된다.

```css
/* Button.module.css */
.btn {
  color: white;
  background-color: tomato;
}
```

```js
// Button.js
import styles from "./Button.module.css";

function Button({ text }) {
  return <button className={styles.btn}>{text}</button>;
}
```

> useEffect

- state가 수정되면 모든 컴포넌트가 다시 렌더링 되는데 특정 부분은 필요시에만 렌더링 될 수 있도록 하는 개념
- useEffet의 첫번째 인자에는 조건에 의해 동작하는 함수를 인자로 설정
- 두번째 인자의 배열에 state 변수를 설정해 React에 전달함으로써 `특정 state가 변할때만` 수행되도록 설정

```js
const [keyword, setKeyword] = useState("");
const [counter, setCounter] = useState(0);
const onClick = () => setCounter((prev) => prev + 1);
const onChange = (event) => setKeyword(event.target.value);
useEffect(() => {
  console.log("i run only once.");
}, []);
useEffect(() => {
  console.log("I run when 'keyword' changes.");
}, [keyword]);
useEffect(() => {
  console.log("I run when 'counter' changes.");
}, [counter]);
useEffect(() => {
  console.log("I run when 'keyword' & 'counter' changes.");
}, [keyword, counter]);
```

<br>

## 어려웠던 점

### `백준 문제 풀이`

> 에디터 문제

```py
import sys

strs1 = list(sys.stdin.readline().rstrip())
strs2 = []

for _ in range(int(sys.stdin.readline())):
    data = sys.stdin.readline().split()
    if data[0] == 'L':
        if strs1:
            strs2.append(strs1.pop())
    elif data[0] == 'D':
        if strs2:
            strs1.append(strs2.pop())
    elif data[0] == 'B':
        if strs1:
            strs1.pop()
    else:
        strs1.append(data[1])

strs1 += reversed(strs2)
# str1.extend(reversed(strs2))
print("".join(strs1))
```

1. 스택 2개를 이용한 풀이 => 스택 2개를 이용해 풀이하므로 insert 및 slice 연산을 사용하지 않아도 되므로 시간초과 발생하지 않음
2. extend 함수는 리스트를 합쳐 주는 동작만 수행하고 반환 값은 반환하지 않는다.
3. 리스트.reverse()와 reversed(리스트)은 똑같은 기능이지만 리스트.reverse()는 리스트가 비어있으면 TypeError, 반면에 reversed(리스트)는 리스트가 비어있어도 Error가 발생하지 않는다.
4. strs1 리스트의 마지막에 커서가 있다고 생각하면 된다.
   - L은 커서가 왼쪽으로 이동하니 strs1의 마지막 item을 str2에 append
   - D는 커서가 오른쪽으로 이동하니 str2의 마지막 item을 str1에 append
   - B는 strs1의 마지막 item을 pop
   - P는 strs1의 마지막 부분에 item을 insert

> 단어 뒤집기 2 문제

```py
text = input()
word = ""
result = ""
tag = False

for s in text:
    if tag == False:
        if s == '<':
            tag = True
            word += s
        elif s == ' ':
            word += s
            result += word
            word = ''
        else:
            word = s + word
    else:
        word += s
        if s == '>':
            tag = False
            result += word
            word = ''

print(result + word)
```

1. tag 안에서 작업 중인지 tag 밖에서 작업중 인지를 먼저 분리
2. tag 안에서 작업 할 때
   - 문자나 공백은 그대로 추가
   - '>'를 만나면 태그가 끝났다는 의미로 tag = False로 변경후 result에 이제까지 누적으로 더한 문자열(word) 더해주기, word 초기화
3. tag 밖에서 작업 할 때
   - 문자를 만났을 때 기존 word의 앞에 문자를 추가함으로써 기존의 문자열과 역순
   - 공백을 만났을 때 word에 공백을 추가한 후 result에 더함
   - '<'를 만나면 태그가 시작된다는 의미로 tag = True로 변경 및 word에 '<' 추가
4. Tag 밖에서 공백을 만나거나 Tag가 닫힐 때 result에 word를 더해준다.
5. 마지막에 word를 더한 이유은 word가 태그의 끝이나 공백을 만나지 못할 수도 있기 때문(문자열 마지막이 Tag의 끝이 아닐 수도 있음, 공백은 무조건 아님)

<br>

## 한줄평

> _오늘도 수고했어!!! 공부할 때 항상 집중해서 하자. TIL 작성할 때도. 당연히 이렇게 해야되 아니면 망한다. 수고했어!!!_

<br>

# 7월 7일

## 오늘 한일

### `이력서 작성`

- 더존비즈온 이력서 작성중
- 메리츠화재 채용연계형 인턴 이력서 작성중

### `React 강의`

- 노마드 코더 React 강의 수강
- Cleanup 함수

### `코딩 테스트`

- 알고리즘 기초 Part 1 `자료구조 1(연습)`문제 풀이
- `오큰수`, `오등큰수` 풀이

### `ES6 부족한 개념 보완`

- JS 순환참조

<br>

## 배운 것

### `JS 순환참조`

- 출처 읽어보기

> 출처

- [구글, "JS 모듈 시스템과 순환 참조 문제", https://ljs0705.medium.com/js-모듈-시스템과-순환-참조-문제-a9e0c90c07e5, (2022.07.07)]

[구글, "js 모듈 시스템과 순환 참조 문제", https://ljs0705.medium.com/js-모듈-시스템과-순환-참조-문제-a9e0c90c07e5, (2022.07.07)]: https://ljs0705.medium.com/js-모듈-시스템과-순환-참조-문제-a9e0c90c07e5

### `React 강의`

> Cleanup 함수

- 컴포넌트 삭제 시 작업
- component가 destroy될 때 뭔가 할 수 있도록 해주는 것
- component가 언제 create 및 destroy 된지 알 수 있다.
- useEffect의 첫번째 인자의 return을 통해 함수(`component가 파괴된 후 작업`)를 반환하도록 설정

```js
function Hello() {
  useEffect(() => {
    console.log("hi :)");
    // componet가 없어질 때 호출
    return () => console.log("bye :(");
  }, []);

  return <h1>Hello</h1>;
}

function App() {
  const [showing, setShowing] = useState(false);
  const onClick = () => {
    setShowing((prev) => !prev);
  };
  return (
    <div>
      {showing ? <Hello /> : null}
      <button onClick={onClick}>{showing ? "Hide" : "Show"}</button>
    </div>
  );
}
```

<br>

## 어려웠던 점

<br>

## 한줄평

> _오늘도 수고했어!!! 내일은 더 집중해서 하자. 오늘처럼 하면 절대 안돼. 정말 고생은 많지만 집중하면서 해야되. 수고했어!!_

<br>
