# 4월 24일

## 오늘 한일

### `알고리즘 문제 풀이`

- 2019 카카오 개발자 겨울 인턴십 Lv2 문제 해설

<br>

## 배운 것

<br>

## 어려웠던 점

### `2019 카카오 개발자 겨울 인턴십 Lv2 튜플`

```
import re

def solution(s):
    result = []
    # 정규 표현식 방법
    dic = s.split(',{')

    dic.sort(key=len)
    for value in dic:
        numbers = re.findall("\d+", value)
        for v in numbers:
            if int(v) not in result:
                result.append(int(v))

    # 현재 배열의 합에서 이전 배열의 합을 뺌으로써 값을 찾는 방법
    s = s[2:-2]
    dic = s.split("},{")
    dic = sorted(dic, key=len)

    result = [int(dic[0])]
    before_sum = result[0]
    for idx, value in enumerate(dic[1:]):
        current_lst = list(map(int, value.split(",")))
        result.append(sum(current_lst) - before_sum)
        before_sum = sum(current_lst)

    return result
```

- 정규 표현식 방법
  - findall(r'패턴 문자열', string) => findall 메소드는 주어진 string 전체에서 pattern과 일치하는 것을 모두 찾아서 list로 반환한다.
  - \d => 숫자를 한글자만 찾는다, \d+ => 하나 혹은 그 이상 연결된 숫자
    - 이 패턴을 사용하지 않으면 두자리 이상 숫자를 쪼개어서 가져온다(333 => ['3', '3', '3'])
- 현재 배열의 합에서 이전 배열의 합을 뺌으로써 값을 찾는 방법
  - 기존의 문자열을 숫자 문자열 리스트로 분리
  - 리스트를 순회하면서 현재 문자열의 합에서 이전 문자열의 합을 뺀 값을 결과 리스트에 추가
    - 현재 문자열의 합에서 이전 문자열의 합을 빼면 이전 문자열의 없었던 숫자를 찾을 수 있다
- 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/courses/30/lessons/64065

### `코딩 테스트 문제에 대한 나의 자세(중요하니까 하루더)`

- 내가 문제를 많이 풀어보지 못했기 때문에 난이도가 높은 문제를 풀지 못하는 것은 당연한 것이므로 좌절할 필요가 없다.
- 문제를 못 풀수는 있지만 이런저런 핑계 되면서 문제 풀이를 이해하는 것에 있어 귀찮음과 두려움을 피하면 아예 알고리즘 문제 푸는 것을 포기하는 것이 더 현명한 선택이다.

<br>

## 한줄평

> _이번 주도 정말 수고했어!!! 내일부터 많이 배우겠다는 마음과 자기 객관화를 통해 나의 지식, 기술의 위치를 인지하면서 공부하자.
> 물론 열심히 하고 있고 잘하고 있지만 지금 내 공부 방법이 틀릴 수도 있고 또 가끔씩 이 정도면 충분하지라는 생각을 하는데 오만한 생각하지 말고 항상 현실을 제대로 인지한 다음에 내 위치에 맞게 지혜롭게 공부하자!!!_

<br>
