# 5월 15일

## 오늘 한일

### `개발자 블로그 비교`

- velog와 티스토리 중에 선택하기

### `CRUD 게시판 구현`

- 로그인 및 로그아웃 기능 구현
- 로그인 유무에 따라 게시판 정보 랜더링 기능 구현

<br>

## 배운 것

### `localStorage 항목 삭제`

- localStorage.clear() => 모든 항목을 삭제
- localStorage.removeItem(key) => 특정 키에 대한 항목을 삭제

<br>

## 어려웠던 점

### `게시판 스티커 내용 수정 및 검색 후 랜더링`

- 현재는 브라우저에 랜더링 되어있는 Element들을 모두 삭제하고 다시 그려주는 방식으로 구현
- 곰곰히 생각해보니 모두 삭제 한 다음에 다시 그리는 것이 비효율적인 것 같다는 생각이 들었다.
- 기존에 랜더링 되 있는 것들 중에 조건에 부한하는 Element만 랜더링 될 수 있게 하는 방법이 더 효율적이지 않을까 생각을 해봤다.

<br>

## 한줄평

> _이번주도 수고했어!!! 게시판 구현하는 거 재미있어서 다행이네 ㅎㅎ 항상 나의 실력, 내가 해야 할 공부를 지혜롭게 선택해서 공부하자! 자만하지 말고 항상 배우겠다는 지혜로운 생각으로 살자!!!_

<br>

# 5월 16일

## 오늘 한일

### `ES6 강의`

- WeakMap

### `CRUD 게시판 구현`

- 검색 기능 구현(제목 또는 내용으로 검색)
- 사용자가 입력한 정보가 포함된 스티거가 1개라도 있다면 랜더링하고 없다면 찾는 정보가 없다고 출력

### `코딩 테스트`

- 파이썬 알고리즘 인터뷰 책 읽기
- 백준 단계별로 풀어보기 `재귀` => `1018번: 체스판 다시 칠하기` 풀기

<br>

## 배운 것

### `WeakMap`

- key/value 구조
- key는 객체여야 하지만 값으로는 아무 값이나 사용할 수 있음
  - Map은 key 값도 아무거나 사용 가능
- Array => set, WeakSet || Object => Map, WeakMap

```
    let wm = new WeakMap();
    let myFun = function(){};

    wm.set(myFun, 0);

    // WeakMap {f => 0}
    console.log(wm);

    let count = 0;
    for(let i=0; i<10; i++){
        count = wm.get(myFun);
        count++;
        wm.set(myFun, count);
    }
    // 10
    console.log(wm.get(myFun));
    myFun = null;
    // false => 더 이상 WeakMap에서 myFun를 관리하지 않겠다.
    console.log(wm.has(myFun));
```

### `WeakMap 활용: private 변수를 클래스에서 만들어서 사용할 때`

- 클래스의 인스턴스가 클래스의 변수에 접근하지 못하게 하기 위한 방법
- private한 변수를 클래스에서 만들어서 사용할 때 외부에 전역 공간을 옮길 수가 있는데 그때 WeakMap을 이용해서 보관하면 굉장히 효율적

```
    const wm = new WeakMap();

    function Area(height, width) {
        wm.set(this, {height, width});
        console.log(wm);
    }

    Area.prototype.getArea = function() {
        const {height, width} = wm.get(this);
        return height * width;
    }

    let myArea = new Area(10, 20);
    // 200
    console.log(myArea.getArea());
    // undefined(클래스 내부 변수에 접근할 수 없음!)
    console.log(myArea.heigth);
```

<br>

## 어려웠던 점

### `게시판 스티커 내용 수정 및 검색 후 랜더링`

- 현재는 브라우저에 랜더링 되어있는 Element들을 모두 삭제하고 다시 그려주는 방식으로 구현(5월 15일)
- 다른 사람들한테 물어보니까 기존에 랜더링 된 것을 모두 삭제하고 조건에 부합한 Element만 다시 랜더링 하는 방법이 보편적이라고 한다.

<br>

## 한줄평

> _오늘 하루도 수고했어!!! 새로운 내용 찾는게 싫고 기존의 것으로 해결하고 싶은 생각이 있지만 그것을 깨야 개발자가 될 수 있어. 좋은 개발자가 되려면 해야하는 것이 아니라 개발자가 되기 위한 최소조건이야. `어렵고 안될 것 같은 두려움과 내 지식으로 해결할 수 있다는 자만심` 버리고 새로운 것을 배우고 이해해서 프로젝트에 적용해야해. 수고했어!!!_

<br>

# 5월 17일

## 오늘 한일

### `ES6 강의`

- 실습예제 2번
- Template

<br>

## 배운 것

### `set 관련 메소드`

- set 인스턴스.values() => set 인스턴스에 있는 아이템들을 모두 반환
- set 인스턴스.size => set은 length말고 size를 이용해 아이탬 개수 반환

### `Template 처리`

- JSON으로 응답을 받고, javascript object로 변환한 후에 어떠한 데이터처리 조작을 한 후에 DOM에 추가
- `데이터 + HTML` 문자열의 결합에 필요

```
    cosnt data = [
        {
            name: 'coffee-bean',
            order: true,
            items: ['americano', 'milk', 'green-tea']
        },
        {
            name: 'starbucks'
            order: false
        }
    ]

    const template = `<div>Welcome ${data[0].name} !!`;
    // "<div>Welcome coffee-bean !!"
    console.log(template);
```

### `Tagged Template literals`

```
    const data = [
        {
            name: "coffee-bean",
            order: true,
            items: ["americano", "milk", "green-tea"],
        },
        {
            name: "starbucks",
            order: false,
        },
    ];

    const template = `<div>Welcome ${data[1].name} !!<div>
      <h2>주문가능항목</h2><div>${data[1].items}</div>`;

    // 이대로 출력하면 items 부분에는 undefined가 출력
    console.log(template);
```

- 위의 문제 해결방법(함수 사용)

  - Template literal의 태그 및 데이터를 사용하려면 기존에 함수 호출하는 방식과 다른 방식 사용
  - 첫번째 매개변수에는 데이터를 기준으로 나눠진 태그(문자열)들로 구성된 배열을 가지고 있음
  - 그외의 매개변수에는 Template literal안의 데이터 값을 차례대로 가지고 있음 => $를 4개 사용했다면 매개변수 4개를 통해 차례대로 데이터 저장

  ```
    // 함수 추가
    function fn(tags, name, items, order) {
        console.log(tags);
        if (typeof items === "undefined") {
            items = "주문가능한 상품이 없습니다";
        }
        // tags[2] = ""이므로 tags[3] 사용
        return tags[0] + name + tags[1] + items + tags[3] + order;
    }

    // 기존의 방식과 다르게 함수 호출
    const template = fn`<div>Welcome ${data[1].name} !!<div>
        <h2>주문가능항목</h2><div>${data[1].items}${data[1].order}</div>`;
    // undefined 대신 함수에서 설정한 값 출력
    console.log(template);
  ```

<br>

## 어려웠던 점

<br>

## 한줄평

> _오늘 하루도 수고했어!!! 새로운 내용 찾는게 싫고 기존의 것으로 해결하고 싶은 생각이 있지만 그것을 깨야 개발자가 될 수 있어. 좋은 개발자가 되려면 해야하는 것이 아니라 개발자가 되기 위한 최소조건이야. `어렵고 안될 것 같은 두려움과 내 지식으로 해결할 수 있다는 자만심` 버리고 새로운 것을 배우고 이해해서 프로젝트에 적용해야해. 수고했어!!!_

<br>

# 5월 19일

## 오늘 한일

### `ES6 강의`

- Arrow function
- function default paramaters
- rest paramaters

### `CRUD 게시판 구현`

- 로그인 Input 및 버튼 디자인 중

<br>

## 배운 것

### `Arrow function`

- 인자로 들어가는 함수의 길이가 너무 긴 문제를 해결하는데 적합

```
    let newArr = [1, 2, 3, 4, 5].map(function (value) {
        return value * 2;
    });
    console.log(newArr);

    let newArr2 = [1, 2, 3, 4, 5].map((value) => {
        return value * 2;
    });
    console.log(newArr2);

    let newArr3 = [1, 2, 3, 4, 5].map((value) => value * 2);
    console.log(newArr3);

    // 3개의 출력값이 모두 동일
```

### `Arrow function의 this context`

- bind 없이 출력하면 this는 window를 가르키기 때문에 printData 메소드를 호출할 수 없다.
- 함수를 bind로 감싸주면서 this가 myObj를 가르키도록 변경

```
    const myObj = {
        runTimeout() {
            setTimeout(
            function () {
                this.printData();
            }.bind(this),200);
        },
        printData() {
            console.log("hi park");
        },
    };

    // "hi park"
    myObj.runTimeout();
```

- arrow를 이용하면 this가 콜백함수(runTimeout)를 감싸주는 Object(myObj2)를 가르키도록 변경

```
    const myObj2 = {
        runTimeout() {
            setTimeout(() => {
            this.printData();
            }, 200);
        },
        printData() {
            console.log("hi park");
        },
    };

    myObj2.runTimeout();
```

### `function default parameter`

- default parameter를 이용해 함수의 매개변수에 기본값을 초기화할 수 있다.
- 함수 호출 시 전달된 인자가 없거나 undefined가 전달된 경우 매개변수를 기본값으로 초기화할 수 있다.

```
    function sum(value, size = { value: 1 }) {
        return value * size.value;
    }

    // 3
    console.log(sum(3));
```

### `rest parameters`

- 함수 호출때 전달했던 인자들을 바로 배열 형태로 변환
- spread랑 비슷
  - rest 파라미터는 매개변수에 ...를 통해 배열로 만든다.
  - spread는 함수를 호출할 때 ...형태로 인자를 넘긴다
  - arr = [1, 2, 3], func(...arr)
- arguments를 Array.from를 통해 진짜 배열로 만드는 작업을 할 필요가 없다.

```
    function checkNum(...argArray) {
        console.log(toString.call(argArray));
        const result = argArray.every((item) => typeof item === "number");
        console.log(result);
    }

    checkNum(10, 2, 3, 4, 11);
```

- Array.every()
  - Array안의 모든 item이 조건식에서 true를 반환하면 최종적으로 true를 반환
  - 한 item이라도 조건식에서 false를 반환하면 최종적으로 false 반환

<br>

## 어려웠던 점

### `focus-within`

- div 태그(user-login) 밑에 input, i, span(.user-form\_\_text) 태그가 있는데 input 태그를 클릭하면 span 태그의 글의 위치가 위로 올라가게 하고 싶었다.
- `div 태그가 focus 됬을 때`랑 `input이 focus 됬을 때` 둘다 안됬다.
- 인터넷을 찾아보다가 자식 태그가 focus되면 작업을 할 수 있는 `focus-within` 가상 선택자를 찾을 수 있게됬다.
- css 선택자를`.user-login:focus-within .user-form__text`로 작성함으로써 input 태그가 foucs되면 span 태그의 위치가 변경되도록 수정했다.

<br>

## 한줄평

> _오늘 하루도 수고했어!!! 새로운 내용 찾는게 싫고 기존의 것으로 해결하고 싶은 생각이 있지만 그것을 깨야 개발자가 될 수 있어. 좋은 개발자가 되려면 해야하는 것이 아니라 개발자가 되기 위한 최소조건이야. `어렵고 안될 것 같은 두려움과 내 지식으로 해결할 수 있다는 자만심` 버리고 새로운 것을 배우고 이해해서 프로젝트에 적용해야해. 수고했어!!!_

<br>
