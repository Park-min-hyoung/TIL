# 10월 23일

## 오늘 한일

### `프론트엔드 데브코스 복습`

- 5일간 들었던 강의에서 배운 개념 복습
- 프로그래머스 자료구조 & 알고리즘 문제 해설 및 개념 숙지
  - 올바른 괄호(Stack), 프린터(Queue), 베스트앨범(HashTable), 가장 먼 노드(Graph), 가장 큰 수(Sort)
  - `이중 배열 만드는 방법, Map 사용, entries 메소드, flatMap 메소드, sort 메소드`
- 강사님이 따로 알아보면 좋다고 추천하신 개념 공부

<br>

## 배운 것

### `js 지식`

<br>

> 싱글 스레드 vs 멀티 스레드

- 스레드
  - 프로세스가 할당받은 자원을 이용하는 실행의 단위
  - 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 Heap, Data, Code 영역을 공유 ( 멀티 스레드의 경우, 이 프로세스의 영역들을 공유한다 )
  - 하나의 프로세스 안에서 다양한 작업을 담당하는 최소 실행 단위를 스레드라고 한다.ex) 크롬 브라우저(=프로세스)에서 벨로그 작성하기(=스레드1) & 유튜브로 음악 듣기(=스레드2)
  - 멀티 스레딩의 경우, 스레드 간의 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시킨다.
  - 각각의 스레드는 독립적인 작업을 수행해야 하기 때문에 고유한 스레드 ID, 프로그램 카운터, 레지스터 집합, 스택을 가지고 있다.
- 멀티 스레드
  - 멀티 스레드는 CPU의 최대 활용을 위해 프로그램의 둘 이상을 동시에 실행하는 기술이다.
  - 스레드 `컨텍스트 스위칭`을 통해 공용 자원 사용 및 여러 작업이 동시에 일어나고 있는 것 처럼 사용자가 느끼게 함.
- 싱글 스레드
  - 하나의 프로세스에서 오직 하나의 스레드로만 실행한다. 그렇기 때문에, 하나의 레지스터와 스택으로 표현이 가능하다.

> MacroTask Queue(일반 Task Queue), MicroTask Queue, Animation Frames

- `사전에 알야 할 것` ⇒ `Task Queue`는 `Web API`가 수행한 비동기 함수를 넘겨받아 `Event Loop`가 해당 함수를 `Call Stack` 에 넘겨줄 때까지 `비동기 함수` 들을 쌓아놓는 곳
- **`MacroTask Queue` ⇒ setTimeout(), setInterval(), setImmediate()와 같은 비동기 함수를 쌓아 놓는다.**
- **`MicroTask Queue` ⇒ Promise나 async/await, process.nextTick, Object.observe, MutationObserver과 같은 비동기 호출을 넘겨받는다.**
- **Animation Frames ⇒ requestAnimationFrame과 같이 브라우저 렌더링과 관련된 task를 넘겨받는 Queue이다.**
- `우선 순위` ⇒ **MicroTask Queue > Animation Frames > MacroTask Queue**
- `주의할 점` ⇒ 이벤트 루프가 큐 방문시에 MicroTask Queue와 Animation Frames는 큐 안에 있는 `모든 작업을 수행` 하는 반면에 MacroTask Queue는 `한 번에 작업 한개` 만 Call Stack에 전달하고 다른 Queue를 순회한다.

<br>

## 어려웠던 점

<br>

## 한줄평

> _이번주도 수고했어!!!_

<br>

# 10월 24일

## 오늘 한일

### `프론트엔드 데브코스`

- core time 참석
- js 강의 수강
- 코딩 과제

<br>

## 배운 것

### `프론트엔드 데브코스`

<br>

#### `js 강의`

<br>

> 이진 탐색

- `정렬` 되어있는 요소들을 반씩 제외하며 찾는 알고리즘
- 이진 탐색 트리 ⇒ 이진 탐색을 위한 이진 트리로 왼쪽 서브 트리는 루트보다 작은 값이 모여있고 오른쪽 서브트리는 루트보다 큰 값이 모여있다.

> DFS, BFS

- BFS, DFS 시간 복잡도
  - V가 정점의 수, E가 간선의 수일 때 BFS의 시간복잡도는 O(V + E)

> 그리디

- 특징
  - 보통 최적해를 구하는 알고리즘보다 빠른 경우가 많다.
  - 크루스칼, 다익스트라 알고리즘 등에 사용
  - 직관적인 문제 풀이에 적합

<br>

## 어려웠던 점

<br>

## 한줄평

> _오늘도 수고했어._

<br>

# 10월 25일

## 오늘 한일

### `프론트엔드 데브코스`

- core time 참석
- 주간 지식 공유 및 데일리 스크럼
- js 강의 수강
- 코딩테스트 대비, 좋은 개발자가 되는 방법 특강

### `스포츠 용병 서비스 팀플`

- review 페이지 구현
- react-query 라이브러리 이용해서 데이터 가져오기
  - 리뷰 페이지 레이아웃 구현
  - react-query를 사용해 DB에서 가져오는 데이터 사용 대비
  - DB에서 넘어온 시간 데이터를 사용자가 보기 쉽게 변환

<br>

## 배운 것

### `프론트엔드 데브코스`

<br>

#### `js 강의`

<br>

> 백트래킹

- 특징
  - 모든 경우의 수를 탐색하는 알고리즘
  - DFS나 BFS를 이용할 수 있다.
  - 효율을 위해 탐색하지 않아도 되는 곳을 미리 막는 것을 `가지치기` 라고 한다.
  - JS는 재귀효율이 나쁘기 때문에 DFS를 구현할 경우 스택 이용이 좋음
    - 코테에선 이를 고려하여 재귀로 작성해도 풀 수 있도록 문제를 제출하는 경우도 있음
  - 탐색에서 순환(Cycle)이 발생할 수 있다면 BFS를 이용하는 것이 편하다.
- 핵심은 `가지치기`
- 작성 방법
  - 우선 모든 경우의 수를 찾을 수 있도록 코딩
  - 이후 문제에서 `특정한 조건` 을 만족하는 것만 탐색하고 나머지는 탐색하지 않도록 조건문을 작성
  - 즉, 절대로 답이 될 수 없는 것은 탐색을 종료
- 문제 => `N-Queen`

> 동적 계획법

- 개념
  - 해결한 작은 문제로 큰 문제를 해결하는 문제 풀이 방식
  - 그리디나 백트래킹처럼 특정 알고리즘이 아닌 문제 해결 방식을 의미
  - 메모리를 많이 사용하는 대신 빠른 성능을 자랑
  - 두가지 방법론이 있다
    - 메모이제이션
    - 타뷸레이션
- 메모이제이션 ⇒ 작은 값들을 저장했다가 사용하는 것
- 문제 접근법
  - 가장 작은 문제를 정의할 수 있는지?
  - 작은 문제를 통해 큰 문제를 해결할 수 있는 규칙이 있는지?
- 문제 => `단어 퍼즐`

<br>

## 어려웠던 점

<br>

## 한줄평

> _오늘도 수고했어._

<br>

# 10월 25일

## 오늘 한일

### `프론트엔드 데브코스`

- core time 참석
- 데일리 스크럼 및 할로윈 관련 이벤트 이야기
- js 강의 수강

### `스포츠 용병 서비스 팀플`

- review 페이지에 들어갈 Paging 기법 공부
- 소스코드 이해 및 내가 사용할 수 있도록 코드 수정
- 임의의 객체 배열 데이터 가져와 정상적으로 페이징 기능 수행되는지 실험

<br>

## 배운 것

### `프론트엔드 데브코스`

<br>

#### `js 강의`

<br>

> 코딩 테스트 준비하는 방법

- 문제를 풀 때 중요한 것
  - 항상 `여러가지 풀이 방법`이 있을 수 있다는 것을 기억
  - 항상 `예외가 있을 수 있다는 것`을 기억
  - 내가 풀어낸 답이 `베스트인지 의심`
  - 문제를 풀었다면 `시행착오를 모두 기록`
  - `다른 사람의 코드`를 많이 보자. 생각하지 못했던 방법을 발견
  - 쉽게 포기하지 말자. `도저히 모르겠다면 답을 보는 것`도 좋은 방법
- 그나마 재밌게 공부하는 법
  - 시각적인 사이트의 도움을 받자
  - 공부하는 자료구조 / 알고리즘이 어디에 쓰일지 생각해보면서 공부
- 마음가짐
  - 알고리즘 마스터가 될 필요는 없다.
  - `어디까지 공부할지` 정해야 함

> 코딩 테스트 잘 보는 법

- 자신의 성향을 파악하자
  - 내가 어떤 사람인지 알아야 함(미리 생각 후 코드 작성 or 코드 작성 후 생각)
- 메모하기
  - 긴장하면 풀다가 내가 무엇을 하려 했는지 잊을 수 있다.
  - 코드에 주석을 달거나 노트에 메모하면서 풀자.
  - 알고리즘은 논리적으로 표현할 수 있다.(헷갈리면 순서도
- 디버깅
  - 내가 예상한대로 동작이 안된다면 꼭 디버깅
  - `console.log 이용`
- 익숙해지기
  - 문제를 잘 읽는 것에 익숙해져야 한다
  - 시간복잡도를 계산하는 것에 익숙해져야 한다
  - 항상 엣지 케이스를 생각하는 것에 익숙해져야 한다.

> 좋은 코드를 만드는 방법

- 간결하고 가독성 좋은 코드
  - 변수, 함수의 이름을 잘 정했는가?
  - 중복 코드를 제거했는가?
  - 함수형 프로그래밍도 좋은 방법(map, filter, reduce와 같은 고차 함수)
- 가지치기를 했는가
  - 백트래킹과 같은 알고리즘에서 사용되지만 그 외 알고리즘에서도 중요
  - 사소한 로직이라면 성능이 크게 개선되지는 않지만 코드 리뷰에서 좋은 평가를 받을 수 있다.
- 자바스크립트를 잘 이용했는가?
  - 자바스크립트로 코딩 테스트를 본다면 문법을 잘 활용해야 한다.(구조 분해 할당, …오퍼레이터)
- 일관성을 유지했는가?
  - var와 let 혼용 x, 카멜과 스네이크 혼용 x, 변수명, 함수명을 줄일거면 줄이고 늘릴거면 늘리고

> HTML과 CSS

- `id와 class의 차이(만약 id가 여러개 있다면 어떻게 처리 될까?)`, `CSS의 선택자 종류`

> DOM

- 트리구조
  - document ⇒ 문서 노드
  - html, head, title, body, h1, a 등등 ⇒ 요소 노드
  - a의 href 같은 것 ⇒ 속성 노드
  - span이나 a 태그 안에 문자 ⇒ 텍스트 노드
- DOM 탐색
  - parentNode ⇒ 선택한 요소 노드의 부모 노드를 불러온다. document의 부모 노드는 null
  - firstElementNode ⇒ 선택한 요소 노드의 자식 요소 노드 중 첫번째를 불러온다. 없을 경우 null 반환
  - children ⇒ 선택한 요소 노드의 모든 자식 요소 노드를 불러온다. 없을 경우 빈 배열을 반환
  - nextElemnetSibling ⇒ 선택한 요소 노드의 다음 형제 요소 노드를 불러온다. 없을 경우 null을 반환
  - previousElementSibling ⇒ 선택한 요소 노드의 이전 형제 요소 노드를 불러온다. 없을 경우 null을 반환
- DOM 조작
  - hasAttribute ⇒ 해당 속성이 있는지 없는지 알 수 있음
  - getAttribute ⇒ 선택한 요소 노드에서 속성의 값을 반환. 없다면 null 반환
  - setAttribute ⇒ 선택한 요소 노드에서 속성을 정의
  - removeAtrribue ⇒ 선택한 요소 노드에서 속성을 제거
  - textContent ⇒ 선택한 요소 노드에서 텍스트 노드에 접근, 변경할 수 있음
  - innerHTML ⇒ XSS 위험이 있음
  - createElement, appendChild, removeChild

> Virtual DOM

- 실제 DOM Tree를 JS 객체로 만든것으로 필요한 정보만 담아 만들어진 것
- React는 `DOM보다 빠르다는 것은 미신` 이고 유지보수 용이한 애플리케이션을 만들도록 도와주고 대부분의 유스케이스에 `충분히 빠를 뿐`
- `document.createDocumentFragment가 하는일?`

<br>

## 어려웠던 점

<br>

## 한줄평

> _오늘도 수고했어._

<br>

# 10월 27일

## 오늘 한일

### `프론트엔드 데브코스`

- core time 참석
- 데일리 스크럼 및 할로윈 관련 이벤트 이야기
- 커피챗 => Pull Request
- js 강의 수강

### `스포츠 용병 서비스 팀플`

- review 페이지에 들어갈 Paging 기법 구현
- 임시 데이터 설정, 기능 구현, 디자인, 소스 코드 정리

<br>

## 배운 것

### `프론트엔드 데브코스`

<br>

#### `js 강의`

<br>

> Editor 만들기

- _contenteditable_ 속성

> JS 사전 퀴즈

```jsx
// 함수 내에서 this를 사용 하게 되면 window를 가르키게 된다.

// 객관식, 주관식 1번
```

```jsx
// 그냥 function 안에서 this를 사용하면 해당 function 스코프를 가르키지만 arrow function 안에서는 자체적으로 스코프를 만들지 않고 상위에 있는 function 스코프를 찾아가기 때문에 this를 사용하면 오류가 없음
// function 함수에 bind를 통해서도 문제해결 할 수 있음
// 클로저를 이용해 변수를 선언해서 문제해결 할 수 있음

// 서술형 1번
```

```jsx
// 서술형 3번

// var => 함수 스코프, 변수 재할당 가능
// let => 블록 스코프, 변수 재할당 가능
// const => 블록 스코프, 변수 재할당 불가능
```

```jsx
// 서술형 4번

// 클로저 => 특정 함수의 내부 변수를 쓰고 있는 함수들은 호출할 수 있으나 내부 변수에는 접근하지 못하므로 private 효과
// 내부에서 값을 조작하는 형태에서도 많이 사용
```

<br>

## 어려웠던 점

<br>

## 한줄평

> _오늘도 수고했어._

<br>

# 10월 28일

## 오늘 한일

### `프론트엔드 데브코스`

- core time 참석
- 데일리 스크럼 및 할로윈 관련 이벤트 이야기
- js 강의 수강
- 코테 중요 개념 일회독
- 프로그래머스 문제(여행 경로, N-Queen) 해설

<br>

## 배운 것

### `프론트엔드 데브코스`

<br>

#### `js 강의`

<br>

> 명령형 프로그래밍과 선언적인 프로그래밍 방식의 이해

- 명령형 프로그램
  - 컴퓨터가 수행할 명령드를 순서대로 써 놓은 것
  - “어떻게 구현하는가”를 디테일하게 기술
- 선언형 프로그램
  - HTML
  - “무엇을 원하는가” ⇒ 컴퓨터가 처리하도록
  - 선언형 프로그램을 지향
  - 어떤 것을 제거하거나 수정하고 추가함에 있어 조건문 보다는 filter, reduce, map 같은 메소드를 사용

> 토글 버튼 만들기 프로그램 구현

<br>

## 어려웠던 점

<br>

## 한줄평

> _오늘도 수고했어._

<br>
