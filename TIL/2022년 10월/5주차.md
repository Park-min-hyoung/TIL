# 10월 23일

## 오늘 한일

### `프론트엔드 데브코스 복습`

- 5일간 들었던 강의에서 배운 개념 복습
- 프로그래머스 자료구조 & 알고리즘 문제 해설 및 개념 숙지
  - 올바른 괄호(Stack), 프린터(Queue), 베스트앨범(HashTable), 가장 먼 노드(Graph), 가장 큰 수(Sort)
  - `이중 배열 만드는 방법, Map 사용, entries 메소드, flatMap 메소드, sort 메소드`
- 강사님이 따로 알아보면 좋다고 추천하신 개념 공부

<br>

## 배운 것

### `js 지식`

<br>

> 싱글 스레드 vs 멀티 스레드

- 스레드
  - 프로세스가 할당받은 자원을 이용하는 실행의 단위
  - 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 Heap, Data, Code 영역을 공유 ( 멀티 스레드의 경우, 이 프로세스의 영역들을 공유한다 )
  - 하나의 프로세스 안에서 다양한 작업을 담당하는 최소 실행 단위를 스레드라고 한다.ex) 크롬 브라우저(=프로세스)에서 벨로그 작성하기(=스레드1) & 유튜브로 음악 듣기(=스레드2)
  - 멀티 스레딩의 경우, 스레드 간의 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시킨다.
  - 각각의 스레드는 독립적인 작업을 수행해야 하기 때문에 고유한 스레드 ID, 프로그램 카운터, 레지스터 집합, 스택을 가지고 있다.
- 멀티 스레드
  - 멀티 스레드는 CPU의 최대 활용을 위해 프로그램의 둘 이상을 동시에 실행하는 기술이다.
  - 스레드 `컨텍스트 스위칭`을 통해 공용 자원 사용 및 여러 작업이 동시에 일어나고 있는 것 처럼 사용자가 느끼게 함.
- 싱글 스레드
  - 하나의 프로세스에서 오직 하나의 스레드로만 실행한다. 그렇기 때문에, 하나의 레지스터와 스택으로 표현이 가능하다.

> MacroTask Queue(일반 Task Queue), MicroTask Queue, Animation Frames

- `사전에 알야 할 것` ⇒ `Task Queue`는 `Web API`가 수행한 비동기 함수를 넘겨받아 `Event Loop`가 해당 함수를 `Call Stack` 에 넘겨줄 때까지 `비동기 함수` 들을 쌓아놓는 곳
- **`MacroTask Queue` ⇒ setTimeout(), setInterval(), setImmediate()와 같은 비동기 함수를 쌓아 놓는다.**
- **`MicroTask Queue` ⇒ Promise나 async/await, process.nextTick, Object.observe, MutationObserver과 같은 비동기 호출을 넘겨받는다.**
- **Animation Frames ⇒ requestAnimationFrame과 같이 브라우저 렌더링과 관련된 task를 넘겨받는 Queue이다.**
- `우선 순위` ⇒ **MicroTask Queue > Animation Frames > MacroTask Queue**
- `주의할 점` ⇒ 이벤트 루프가 큐 방문시에 MicroTask Queue와 Animation Frames는 큐 안에 있는 `모든 작업을 수행` 하는 반면에 MacroTask Queue는 `한 번에 작업 한개` 만 Call Stack에 전달하고 다른 Queue를 순회한다.

<br>

## 어려웠던 점

<br>

## 한줄평

> _이번주도 수고했어!!!_

<br>

# 10월 24일

## 오늘 한일

### `프론트엔드 데브코스`

- core time 참석
- js 강의 수강
- 코딩 과제

<br>

## 배운 것

### `프론트엔드 데브코스`

<br>

#### `js 강의`

<br>

> 이진 탐색

- `정렬` 되어있는 요소들을 반씩 제외하며 찾는 알고리즘
- 이진 탐색 트리 ⇒ 이진 탐색을 위한 이진 트리로 왼쪽 서브 트리는 루트보다 작은 값이 모여있고 오른쪽 서브트리는 루트보다 큰 값이 모여있다.

> DFS, BFS

- BFS, DFS 시간 복잡도
  - V가 정점의 수, E가 간선의 수일 때 BFS의 시간복잡도는 O(V + E)

> 그리디

- 특징
  - 보통 최적해를 구하는 알고리즘보다 빠른 경우가 많다.
  - 크루스칼, 다익스트라 알고리즘 등에 사용
  - 직관적인 문제 풀이에 적합

<br>

## 어려웠던 점

<br>

## 한줄평

> _오늘도 수고했어._

<br>

# 10월 25일

## 오늘 한일

### `프론트엔드 데브코스`

- core time 참석
- 주간 지식 공유 및 데일리 스크럼
- js 강의 수강
- 코딩테스트 대비, 좋은 개발자가 되는 방법 특강

### `스포츠 용병 서비스 팀플`

- review 페이지 구현
- react-query 라이브러리 이용해서 데이터 가져오기
  - 리뷰 페이지 레이아웃 구현
  - react-query를 사용해 DB에서 가져오는 데이터 사용 대비
  - DB에서 넘어온 시간 데이터를 사용자가 보기 쉽게 변환

<br>

## 배운 것

### `프론트엔드 데브코스`

<br>

#### `js 강의`

<br>

> 백트래킹

- 특징
  - 모든 경우의 수를 탐색하는 알고리즘
  - DFS나 BFS를 이용할 수 있다.
  - 효율을 위해 탐색하지 않아도 되는 곳을 미리 막는 것을 `가지치기` 라고 한다.
  - JS는 재귀효율이 나쁘기 때문에 DFS를 구현할 경우 스택 이용이 좋음
    - 코테에선 이를 고려하여 재귀로 작성해도 풀 수 있도록 문제를 제출하는 경우도 있음
  - 탐색에서 순환(Cycle)이 발생할 수 있다면 BFS를 이용하는 것이 편하다.
- 핵심은 `가지치기`
- 작성 방법
  - 우선 모든 경우의 수를 찾을 수 있도록 코딩
  - 이후 문제에서 `특정한 조건` 을 만족하는 것만 탐색하고 나머지는 탐색하지 않도록 조건문을 작성
  - 즉, 절대로 답이 될 수 없는 것은 탐색을 종료
- 문제 => `N-Queen`

> 동적 계획법

- 개념
  - 해결한 작은 문제로 큰 문제를 해결하는 문제 풀이 방식
  - 그리디나 백트래킹처럼 특정 알고리즘이 아닌 문제 해결 방식을 의미
  - 메모리를 많이 사용하는 대신 빠른 성능을 자랑
  - 두가지 방법론이 있다
    - 메모이제이션
    - 타뷸레이션
- 메모이제이션 ⇒ 작은 값들을 저장했다가 사용하는 것
- 문제 접근법
  - 가장 작은 문제를 정의할 수 있는지?
  - 작은 문제를 통해 큰 문제를 해결할 수 있는 규칙이 있는지?
- 문제 => `단어 퍼즐`

<br>

## 어려웠던 점

<br>

## 한줄평

> _오늘도 수고했어._

<br>
