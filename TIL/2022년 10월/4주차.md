# 10월 16일

## 오늘 한일

### `정리`

- 협업 관련 과정 및 정보 정리
- 자소서 답변 notion에 정리
- 프론트엔드 데브코스 행정 및 주요 사이트 내용 숙지 및 notion에 정리

### `스포츠 용병 서비스 팀플`

- MatchList render

<br>

## 배운 것

<br>

## 어려웠던 점

<br>

## 한줄평

> _오늘도 수고했어. 내일부터 힘들텐데 한번 이겨내보자. 화이팅!_

<br>

# 10월 17일

## 오늘 한일

### `이력서`

- 넷마블 이력서 작성 완료

### `프론트엔드 데브코스`

- core time 참석
- js 강의 수강

<br>

## 배운 것

### `프론트엔드 데브코스`

<br>

#### `js 강의`

> 변수, 상수, 자료형, 메모리

- 변수(var, let) => var는 권장하지 않음
- 상수(const) => 값을 할당한 후에 값을 수정할 수 없다.
- 자료형 => Nuber, String, Boolean, Object, Array, Function, Undefined, Null
- 메모리

  - 할당, 사용, 해제
  - Garbage Collector를 통해 사용하지 않는 자원들을 해제

> 메모리 심화

- 변수는 값을 바라보고 있는 것이 아니라 메모리 주소를 보고있다.
  - let variable = 126(1번 주소 참조), let variable2 = variable(1번 주소 참조),
  - 기존 변수 조작 => variable = variable + 1(새로운 메모리 주소(2번)를 참조)
  - 원시 타입은 변경이 불가능하기 때문에 변수를 조작하게 되면 새로운 주소를 할당 받아 값을 넣는다.
- Virtual Machine

  - 변수들이 `변수 = 주소`형태로 Heap과 Call Stack에 쌓여 있다.
  - Heap => 참조 타입이 들어가 있는 곳, 동적으로 영역 크기가 변할 수 있음
  - Call Stack => 원시 타입이 들어가 있는 곳
  - 배열은 Call Stack과 Heap에 둘다 할당되있는데 Call Stack에서 Heap의 것을 참조하는 형태
  - const로 선언한 배열이 push가 가능한 이유는 Call stack에 할당된 메모리를 변경하는 것이 아니라 Heap에 할당된 메모리를 변경하는 것이기 때문

- 표현식과 연산자

  - 표현식 => 숫자, 문자열, 논리값 같은 원시 값을 포함하여 변수, 상수, 함수 호출 등으로 조합

> 배열과 객체

```js
// ------------배열 생성------------
const arr1 = new Array();
const arr2 = [];
const arr3 = [1, 2, 3, 4];
const arr4 = new Array(5);
const arr5 = new Array(5).fill(5); // [5, 5, 5, 5, 5]
const arr6 = Array.from(Array(5), function (v, k) {
  return k + 1;
}); // [1, 2, 3, 4, 5]

// ------------배열 함수------------
const arr = [1, 2, 3, 4, 5, 6];
const arr2 = [7, 8, 9, 10];

// join, reverse, concat
console.log(arr.join(", ")); // 1, 2, 3, 4, 5, 6
console.log(arr.reverse()); // [6, 5, 4, 3, 2, 1];
console.log(arr); // [6, 5, 4, 3, 2, 1]; // reverse 사용하면 기존의 arr에도 영향
console.log(arr.concat(arr2)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// push, pop
arr.push(7);
console.log(arr); // [1, 2, 3, 4, 5, 6, 7]
console.log(arr.pop()); // 7
console.log(arr); // [1, 2, 3, 4, 5, 6]

// shift, unshift
arr.shift();
console.log(arr); // [2, 3, 4, 5, 6]
arr.unshift(10);
console.log(arr); // [10, 2, 3, 4, 5, 6]

// slice, splice
console.log(arr.slice(2, 4)); // [3, 4]
arr.splice(2, 2); // 2번 index부터 2개를 삭제
console.log(arr); // [1, 2, 5, 6]

// 순회(for of)
for (const item of arr) {
  console.log(item); // 각 아이템이 개행되서 출력
}

// ------------객체------------
const obj1 = new Object();
const obj2 = {};
const obj3 = { name: "park", company: "house" };

// 추가, 삭제, key 여부, key-value 집합
obj3["email"] = "qkralswgud1324@naver.com";
obj3.phone = "01011111111";

delete obj3.phone;

console.log("email" in obj3);
console.log("phone" in obj3);

console.log(Object.keys(obj3)); // ['name', 'company', 'email']
console.log(Object.values(obj3)); // ['park', 'house', 'qkralswgud1324@naver.com']
for (const key in obj3) {
  console.log(key, obj3[key]); // name park <개행> company house 형식으로 출력
}
```

> 스코프와 클로저

- 스코프
  - 유효 범위라고도 부르며 변수가 어느 범위까지 참조되는지를 뜻함
  - var는 함수 수준 스코프인 반면에 let과 const는 블록 수준 스코프이다.
- 클로저
  - 함수가 선언된 환경의 스코프를 기억하여 함수가 스코프 밖에서 실행될 때에도 기억한 스코프에 접근할 수 있게 만드는 문법
  - 은닉화 => 클로저를 이용하여 내부 변수와 함수를 숨길 수 있다.
  - 유용하게 사용하기 보단 알기 힘든 버그를 잘 수정하기 위해서 사용

<br>

## 어려웠던 점

<br>

## 한줄평

> _오늘도 수고했어. 내일도 힘내서 힘내자._

<br>

# 10월 18일

## 오늘 한일

### `스포츠 용병 서비스 팀플`

- React를 이용한 무한 스크롤 기능 구현하는 방법 공부

### `면접 준비`

- 자소서 복기 및 기업 분석

### `프론트엔드 데브코스`

- core time 참석
- js 강의 수강

<br>

## 배운 것

### `프론트엔드 데브코스`

<br>

#### `js 강의`

> **`네트워크 기초`**

- URL을 해석
- DNS를 조회 => DNS는 도메인과 IP 주소를 서로 변환
- 해당 IP가 존재하는 서버로 이동 => 네트워크 장비 라우터를 통해 이동
- ARP를 이용하여 MAC 주소 변환
- TCP 통신을 통해 Socket을 열어야 함
- 서버는 응답을 반환 => HTTP 프로토콜로 들어온 패킷을 읽고 처리
- 브라우저는 렌더링 => HTML을 읽어 DOM Tree를 구축

> **`컴퓨터 시간 원리`**

- Unix TIme
  - 1970년 1월 1일 0시 0분 0초가 기준 시각

> **`암호화 기초`**

- 암호화
  - 평문을 해독할 수 없는 암호문으로 변환하는 것을 의미
- 단방향 암호화
  - 해시 알고리즘을 이용하여 평문을 복호화할 수 없는 형태로 암호화
  - 대표적으로 MD5와 SHA 알고리즘
- Salt
  - 평문에 임의의 문자열을 추가하여 암호화하는 방법
- Key Stretching
  - 해시를 여러번 반복하여 원문을 알기 힘들게 만드는 방법
- 양방향
  - 평문을 복호화 할 수 있는 형태로 암호화(대칭키와 비대칭키 알고리즘으로 나뉨)
  - 대칭키 => AED, 비대칭키 => RSA

> **`함수형 프로그래밍`**

- 함수형 프로그래밍의 장점
  - 상태가 없기 때문에 사이드 이펙트가 없다
  - 재사용성이 높다(단점 함수가 너무 많을 수 있다)
  - 코드가 짧고 간결하다(단점 많은 숙련도 필요)
- 선언형 프로그래밍
  - 명령형 프로그래밍 => 문제를 어떻게 해결해야 하는지 컴퓨터에게 명령
  - 선언형 프로그래밍 => 무엇을 해결해야 할지 집중하고 해결 방법은 컴퓨터에게 위임

> **`객체지향과 프로토타입`**

- 객체지향
  - 객체 위주로 설계하고 프로그래밍하는 패러다임
  - 객체지향 언어에선 추상화의 최소 단위가 객체
- 객체지향의 오해
  - js는 프로토타입을 통해 객체지향을 표현할 수 있다.
- 프로토타입
  - 기존의 객체를 복사하여 새로운 객체를 생성하는 방식
  - Object.create => 기존 객체를 재활용할 수 있다.

> **`이벤트 루프`**

- js는 Heap과 Call Stack으로 이뤄진 단일 스레드로 동작
- js는 단일 스레드이지만 웹 브라우저는 멀티 스레드이기 때문에 DOM Event, AJAX, Timer와 같은 것을 이용할 수 있음
- `Task Queue, Mircotask Queue, Animation frames` 알아보기

> **`모듈`**

- 모듈과 컴포넌트 비교
  - 모듈은 설계 시점에 의미있는 요소며 컴포넌트는 런타임 시점에 의미있는 요소
  - 모듈안에 component가 있다고 보면 됨
- 모듈의 특징(`<script src="module"></script>`)
  - 항상 use strict(엄격모드) => 그냥 script 안에서는 let이나 var로 변수선언을 하지 않아도 되는 반면 module에서는 키워드 사용해서 선언해야 함
  - 모듈 레벨 스코프가 있다 => 그냥 script 끼리는 전역 스코프를 참조해서 서로 각자의 변수를 사용할 수 있지만, module에서는 import 및 export 하지 않으면 서로 각자의 변수를 사요할 수 없다.
  - 단 한 번만 평가 => script 2개가 똑같은 모듈을 import 해도 첫번째에서 import 했기 때문에 두번째에서는 평가되지 않고 사용만 한다.
  - 지연 실행 => DOM이 모두 만들어진 후 실행, `defer`를 적용한 것과 같다.

> **`유니코드`**

- CCS(Coded Character Set)
  - 문자들을 Code Point에 대응시켜 만든 코드화된 문자들의 집합
  - Code Point는 Character의 식별자
  - KS C 5601, ISO 10646, US-ASCII
- CES(Character Encoding Scheme)
  - CCS를 8bit 집합에 대응
  - UTF-8, euc-kr
- TES(Transfer Encoding Syntax)
  - 인코딩한 문자가 특정 프로토콜을 타고 전송되도록 변환
  - URL Encoding
- 한글과 영어는 1문자당 2바이트를 차지하고 있어서 길이를 출력하면 1이고 이모티콘은 1개당 4바이트를 차지하고 있어서 길이를 출력하면 2

> **`정규표현식`**

- 정규표현식 목적
  - 문자 검색, 문자 대체, 문자 추출
  - 느리지만 짧은 문자에 사용하기 때문에 성능과 관련한 이슈는 크게 문제가 되지 않음
- 모양
  - "/regexr/i"(왼쪽 부터 시작, 패턴, 종료기호, 플래그)
  - `정규 표현식 연습 => regexone.com, alf.nu/RegexGolf(정규표현식 게임)`
- js에서 사용
  - RegExp 객체로 정규표현식 기능 제공
  - test(regExp) => 정규표현식 조건에 해당하는 문자열이 있다면 true, 없다면 false
  - exec(regExp) => 조건에 부합한 문자열이 있다면 그 문자열, 위치, 전체 문자열을 배열형태로 반환, 없다면 null
  - match(regExp) => 위에는 정규표현식 객체를 통해 사용 하지만 `문자열 객체.match()` 형태로 사용 가능, exec와 비슷
  - replace(regExp, 대체문자열) => match와 마찬가지로 문자열 객체에 사용 가능하고 조건에 부합하는 문자열을 대체문자열로 수정
  - search(regExp) => 해당 패턴이 있다면 일치한 패턴 정보의 위치를 반환, 모두 탐색하려면 matchAll과 g를 사용
  - `개미수열 문제 정규표현식을 통해 풀이 => ko.wikipedia.org/wiki/읽고_말하기_수열`, 5를 입력 받으면 "111221" 출력, 힌트: Run-length encoding

> **`쿠키와 세션, 웹 스토리지`**

- HTTP 통신
  - HTTP Request는 기본적으로 상태가 존재하지 않는다.
  - 따라서 서버는 어떤 브라우저에서 요청이 온 것인지 알 수 없다.
  - 이때 헤더에 쿠키를 담으면 서버가 쿠키를 읽어 어디서 온 것인지 알 수 있다.
- Cookie
  - 클라이언트에서 저장, 관리하는 데이터들. 브라우저를 닫아도 데이터를 유지할 수 있다.,
  - 서버에서 Set-Cookie를 응답 헤더로 내려주면 클라이언트는 받아서 저장
  - 클라이언트에서 자체적으로 조작할 수 있다
  - 각 상태에 수명을 정할 수 있다.
- Set-Cookie
  - Set-Cookie: 키-값;
  - 응답 헤더에 담으면 브라우저가 알아서 저장
  - 각 데이터에 여러옵션이 존재(Expires, Secure(HTTPS에서만 쿠키전송), HttpOnly(js에서 쿠키에 접근 못하도록 막음), Max-Age(쿠키 수명), Domain(도메인이 일치하는 요청만 쿠키 전송), Path(패스가 일치...)
- 쿠키의 취약점
  - XSS(Cross-site Script) 공격
  - JS를 이용해 악의적인 사용자가 다른 사용자의 쿠키값을 탈취 할 수 있다.
  - 쿠키를 암호화하지 않고 보내면 쿠키값을 중간에 탈취 당할 가능성이 있다 => HTTPS를 통해 해결
- Session
  - 클라이언트가 서버쪽으로 쿠키를 보냄에 있어 서버가 어떤 클라이언트가 보냈는지 확인할 수 있어야 한다.
  - HTTP Session ID를 식별자로 사용자를 구분
  - 클라이언트는 HTTP Session ID를 쿠키 형태로 저장
  - 서버 자체적으로 기록하고 관리
- Session과 관련해서 문제가 많아 이제는 서버와 클라이언트가 인증은 `별도 토큰`을 사용하고 쿠키는 클라이언트 자체적인 `지속적인 데이터 관리 용도`로 많이 사용
- Cookie 대처
  - 웹 스토리지 => 쿠키에서 하기 힘든 것들을 지원하기 위해 등장
  - 로컬 스토리지 => 브라우저를 종료해도 계속해서 데이터가 남는다, 쿠기와 마찬가지고 Key-Value 형태로 저장
  - 세션 스토리지 => 브라우저를 닫는 순간 데이터 사라진다, 같은 도메인이어도 세션이 다르면 데이터 접근 x, Key-Value 형태 저장

<br>

## 어려웠던 점

<br>

## 한줄평

> _오늘도 수고했어. 조금만 더 집중해서 공부하자. 집중안하면 정말 공부안하는 것이 내 인생에 훨씬 도움될 정도로 아무 의미 없는 행동이야._

<br>

# 10월 19일

## 오늘 한일

### `면접 준비`

- 자소서 복기 및 기업 분석

### `역검`

- KB 국민은행 역검

### `프론트엔드 데브코스`

- core time 참석
- js 강의 수강

<br>

## 배운 것

### `프론트엔드 데브코스`

<br>

#### `js 강의`

<br>

> 자료구조 & 알고리즘

- 실무에서 중요한 세가지
  - 기초 코딩 능력, 전문 분야 지식, 기본 CS 지식

> 자료구조

- 종류
  - 단순 구조(정수, 실수, 문자열, 논리), 선형 구조(배열, 연결 리스트, 스택, 큐), 비선형 구조(트리, 그래프)

> 시간잡도

- 빅오 표기법

> 배열

- 특징
  - 고정된 크기를 가지며 일반적으로 동적으로 크기를 늘리 수없다.(다른언어)
  - js처럼 대부분의 언어는 동적으로 크기가 증감되도록 만들어져 있다.
  - 추가와 삭제(O(n))가 반복되는 로직이라면 배열 사용 권장x

> 연결리스트

- 특징
  - 메모리가 허용하는한 요소를 제한없이 추가할 수 있다
  - 탐색은 O(n), 요소를 추가하거나 제거할 때는 O(1)
  - 싱글, 더블, 써큘러 링크리스트가 있음
- 배열과 차이점
  - 배열은 데이터를 메모리에 저장함에 있어 연속적인 공간을 사용하는 반면에 링크드 리스트는 각자 다른 메모리 공간의 데이터를 포인터를 통해 연결
- 싱글링크드리스트
  - `싱글링크드리스트 클래스에 리스트 크기를 구하는 'size' 메소드를 만들어보세요. 만들어진 싱글링크드리스트는 예외처리가 되어있지 않습니다. 예외가 발생해도 동작하도록 모든 예외를 찾아 수정`
- 더블링크드리스트
  - `더블링크드리스트 구현`
- 써큘러링크드리스트
  - `써큘러링크드리스트 구현`

> 프로그래머스 `올바른 괄호` 문제 풀이

<br>

## 어려웠던 점

<br>

## 한줄평

<br>

> _오늘도 수고했어. 내일도 열심히 하자._

<br>

# 10월 20일

## 오늘 한일

### `프론트엔드 데브코스`

- core time 참석
- GitHub 특강
- js 강의 수강

<br>

## 배운 것

### `프론트엔드 데브코스`

<br>

#### `GitHub 특강`

<br>

> `실무에서 자주 사용하는 명령어`

- amend: 깜빡하고 수정 못한 파일이 있어요, 방금 만든 커밋에 살짝 추가하고 싶어요
- stash: 변경사항을 잠시 킵해두고 싶어요, 아직 커밋은 안 만들래요
- reset: 옛날 커밋으로 브랜치를 되돌리고 싶어요
- revert: 이 커밋의 변경사항을 되돌리고 싶어요
  - 과거의 커밋중 마음에 안드는게 있어 reset 하려는데 최근까지 좋은 커밋들이 많아서 reset 하기는 좀 그럴때 사용
- cherry-pick: 저 커밋 하나만 떼서 지금 브랜치에 붙이고 싶어요

<br>

#### `js 강의`

<br>

> Queue, HashTable

- Queue와 HashTable 구현하는 방법 및 문제 풀이

<br>

## 어려웠던 점

<br>

## 한줄평

> _오늘도 수고했어._

<br>
