# 10월 16일

## 오늘 한일

### `정리`

- 협업 관련 과정 및 정보 정리
- 자소서 답변 notion에 정리
- 프론트엔드 데브코스 행정 및 주요 사이트 내용 숙지 및 notion에 정리

### `스포츠 용병 서비스 팀플`

- MatchList render

<br>

## 배운 것

<br>

## 어려웠던 점

<br>

## 한줄평

> _오늘도 수고했어. 내일부터 힘들텐데 한번 이겨내보자. 화이팅!_

<br>

# 10월 17일

## 오늘 한일

### `이력서`

- 넷마블 이력서 작성 완료

### `프론트엔드 데브코스`

- core time 참석
- js 강의 수강

<br>

## 배운 것

### `프론트엔드 데브코스`

<br>

#### `js 강의`

> 변수, 상수, 자료형, 메모리

- 변수(var, let) => var는 권장하지 않음
- 상수(const) => 값을 할당한 후에 값을 수정할 수 없다.
- 자료형 => Nuber, String, Boolean, Object, Array, Function, Undefined, Null
- 메모리

  - 할당, 사용, 해제
  - Garbage Collector를 통해 사용하지 않는 자원들을 해제

> 메모리 심화

- 변수는 값을 바라보고 있는 것이 아니라 메모리 주소를 보고있다.
  - let variable = 126(1번 주소 참조), let variable2 = variable(1번 주소 참조),
  - 기존 변수 조작 => variable = variable + 1(새로운 메모리 주소(2번)를 참조)
  - 원시 타입은 변경이 불가능하기 때문에 변수를 조작하게 되면 새로운 주소를 할당 받아 값을 넣는다.
- Virtual Machine

  - 변수들이 `변수 = 주소`형태로 Heap과 Call Stack에 쌓여 있다.
  - Heap => 참조 타입이 들어가 있는 곳, 동적으로 영역 크기가 변할 수 있음
  - Call Stack => 원시 타입이 들어가 있는 곳
  - 배열은 Call Stack과 Heap에 둘다 할당되있는데 Call Stack에서 Heap의 것을 참조하는 형태
  - const로 선언한 배열이 push가 가능한 이유는 Call stack에 할당된 메모리를 변경하는 것이 아니라 Heap에 할당된 메모리를 변경하는 것이기 때문

- 표현식과 연산자

  - 표현식 => 숫자, 문자열, 논리값 같은 원시 값을 포함하여 변수, 상수, 함수 호출 등으로 조합

> 배열과 객체

```js
// ------------배열 생성------------
const arr1 = new Array();
const arr2 = [];
const arr3 = [1, 2, 3, 4];
const arr4 = new Array(5);
const arr5 = new Array(5).fill(5); // [5, 5, 5, 5, 5]
const arr6 = Array.from(Array(5), function (v, k) {
  return k + 1;
}); // [1, 2, 3, 4, 5]

// ------------배열 함수------------
const arr = [1, 2, 3, 4, 5, 6];
const arr2 = [7, 8, 9, 10];

// join, reverse, concat
console.log(arr.join(", ")); // 1, 2, 3, 4, 5, 6
console.log(arr.reverse()); // [6, 5, 4, 3, 2, 1];
console.log(arr); // [6, 5, 4, 3, 2, 1]; // reverse 사용하면 기존의 arr에도 영향
console.log(arr.concat(arr2)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// push, pop
arr.push(7);
console.log(arr); // [1, 2, 3, 4, 5, 6, 7]
console.log(arr.pop()); // 7
console.log(arr); // [1, 2, 3, 4, 5, 6]

// shift, unshift
arr.shift();
console.log(arr); // [2, 3, 4, 5, 6]
arr.unshift(10);
console.log(arr); // [10, 2, 3, 4, 5, 6]

// slice, splice
console.log(arr.slice(2, 4)); // [3, 4]
arr.splice(2, 2); // 2번 index부터 2개를 삭제
console.log(arr); // [1, 2, 5, 6]

// 순회(for of)
for (const item of arr) {
  console.log(item); // 각 아이템이 개행되서 출력
}

// ------------객체------------
const obj1 = new Object();
const obj2 = {};
const obj3 = { name: "park", company: "house" };

// 추가, 삭제, key 여부, key-value 집합
obj3["email"] = "qkralswgud1324@naver.com";
obj3.phone = "01011111111";

delete obj3.phone;

console.log("email" in obj3);
console.log("phone" in obj3);

console.log(Object.keys(obj3)); // ['name', 'company', 'email']
console.log(Object.values(obj3)); // ['park', 'house', 'qkralswgud1324@naver.com']
for (const key in obj3) {
  console.log(key, obj3[key]); // name park <개행> company house 형식으로 출력
}
```

> 스코프와 클로저

- 스코프
  - 유효 범위라고도 부르며 변수가 어느 범위까지 참조되는지를 뜻함
  - var는 함수 수준 스코프인 반면에 let과 const는 블록 수준 스코프이다.
- 클로저
  - 함수가 선언된 환경의 스코프를 기억하여 함수가 스코프 밖에서 실행될 때에도 기억한 스코프에 접근할 수 있게 만드는 문법
  - 은닉화 => 클로저를 이용하여 내부 변수와 함수를 숨길 수 있다.
  - 유용하게 사용하기 보단 알기 힘든 버그를 잘 수정하기 위해서 사용

<br>

## 어려웠던 점

<br>

## 한줄평

> _오늘도 수고했어. 내일도 힘내서 힘내자._

<br>
